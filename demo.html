<!doctype html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<title>jQuery PHP</title>
<script type="text/javascript" src="lib/jquery-1.8.3.min.js"></script>
<script type="text/javascript" src="lib/jquery.php.js"></script>
<style>
body {
	margin:40px;
}
.results { 
	border:1px dashed green;
	width:100%;
	margin-bottom:10px;
	font-family:"Courier New", Courier, monospace;
	font-weight:bold;
	white-space:pre;
	padding:5px;
	color:#666;
}
</style>
</head>
<script>
$(document).ready(function() {
	
	// Optionally define a shortcut reference
	var P = $.fn.php;
	

	
	// Initialization options
	P('init', 
		{
			// The path to our function request handler is absolutely required
			'path': 'http://www.williamneeley.com/code/jqueryphp/lib/func_request.php',
			
			// Synchronous requests are required for method chaining functionality
			'async': false,
			
			// List any user defined functions in the manner prescribed here
			'userFunctions': {

			}
		});
	

	
	/* This is an example of setting our callback globally. This must be done at least
	 * one time before calling any PHP functions.
	 */
	P(function callback(data, self) {
		$(self).append("<div>" + data + "</div>");
	});
	
	// This is another way to set our global callback function.
	P('callback', function(data, self) {
		$(self).append("<span>" + data + "</span>");
	});



	/* Here we specify seperately the jQuery selected elements we would like our bound context 
	 * to be. This will override any previously selected elements. You can optionally define the
	 * element(s) context while calling PHP functions as demonstrated in examples below.
	 */
	P('select', $("#results1"));
	

	
	/* The following are some simple usage scenarios. It should be noted that the examples below
	 * demonstrate multiple ways to do the same thing. In this case we are calling PHP's 'strlen' 
	 * function.
	 */
	 
	// Passing the 'call' keyword is allowed but not required.
	P('call', 'strlen', 'A test string!');	
	
	// Assinging your callback with the function name call is also possible (again not required).		
	P(function call(data, self) {
		$(self).append("<br><i>" + data + "</i>");
	}, 'strlen', 'A test string!');	
	
	// Passing the function you wish to use as a string as the first parameter.
	P('strlen', 'A longer test string!');
	
	// Assinging the function you wish to call as the name of the callback.
	P(function strlen(data, self) {
		$(self).append("<br><u>" + data + "</u>");
	}, 'A shorter string!');

	// Calling your function while setting a new global callback.
	P('strlen', function(data, self) {
		$(self).append("<br><u style='color: red'>" + data + "</u>");
	}, 'This will be the longest string passed to strlen yet!');
	
	// Calling your function while choosing a new selector context and setting a new callback.
	$("#results1").php('strlen', function(data, self) {
		$(self).append("<br><u style='color: green'>" + data + "</u>");
	}, 'This will be the longest string passed to strlen yet (plus one)!');
	
	// Perhaps the simplest way of calling your PHP function.
	P.strlen('I am a string.');
	
	// Calling your function while choosing a new selector context without setting a new callback.
	$("#results2").php('strlen', 'Yet another string!');
	
	
	
	// Now let's switch our selector context to another div
	P('select', $("#results2"));
	
	// Let's set another callback function (if you don't further requests will just use the last one).
	P('callback', function(data, self) {
		$(self).append("<div style='font-size: 2.0em;'>" + data + "</div>");
	});
	
	// And we call PHP's crypt function on the passed string.
	P.crypt("My encrypted passphrase.");
	
	// Now let's switch our selector context to another div
	P('select', $("#results3"));
	
	
	
	/* This is an example of calling multiple consecutive functions as an object by passing the function 
	 * name as the key and then an array of values pertaining to a given function's parameters. This does
	 * not work in the same manner as function chaining. Each function is called and value is returned
	 * independantly. It's just a shorthand approach to calling multiple functions.
	 */
	P(function multi(data, self) {
		$(self).append("<div>" + data + "</div>");
	},
	{
		abs : [-884],
		cosh : [23],
		sqrt : [43]
	});
	
	// Let's highlight a PHP string of code using our 'multi' functionality.
	P('multi',
	{
		highlight_string : ["<?php $a = 2; $b = 2; $c = $a + $b; echo $c; ?>"],
	});
	
	// Let's run the 'pi' function and then the 'data' function.
	$("#results4").php('multi',
	{
		pi : [700],
		date : ["DATE_RFC822"]
	});
	
	
	
	/* Example demonstrating the usage of jQuery.php's exec method to pass PHP code to the backend and 
	 * return the result. This method is disabled by default. This functionality MAY be deprecated in 
	 * future releases.
	 */
	var code = "$a = 2; $b = 2; $c = $a + $b; echo $c;"
	P('exec', code, function(data, self) {
		$(self).html(data);
	});



	// Now let's switch our selector context to another div
	P('select', $("#results5"));

	/* This is an example of calling PHP functions using a function chaining pattern. It is imperative 
	 * that we pass our callback argument as the first argument to .php. In addition, it naming the 
	 * callback function 'chain' is required.
	 */
	P(function chain(data, self) {
		$(self).append("<div style='border:2px dashed blue'>" + data + "</div>");
	}, -138)
		.abs()
		.tan();
	
	/* When passing parameters to a chain just think of the first function in the chain to
	 * know which parameters to pass. It is the returned results of the first function that
	 * all other functions in the chain act on.
	 */
	P('chain', function(data, self) {
		$(self).append("<div style='border:2px dashed yellow'>" + data + "</div>");
	}, 2, 8)
		.pow()
		.pi();
	
	// Let's quickly override our global callback function.
	P(function callback(data, self) {
		$(self).append("<div style='border:2px dashed green'>" + data + "</div>");
	});
	
	/* Remember defining a callback was not required. Just keep in mind that if we do not 
	 * override or set our callback, the last used callback will be used once more.
	 */
	P('chain', 8, 3).pow().pi();
	
	// Let's see if our data can be returned to a JavaScript variable
	var result = P('chain', 8, 3).pow().tan().abs().round();
	console.log( result.data );
	
	// Now let's switch our selector context to another div
	P('select', $("#results6"));
	
	// Now let's define our callback.
	P(function callback(data, self) {
		$(self).append('<div style="1px dotted red">' + data + '</div>');
	});



	/* In many cases we will want to return data from a PHP function request to a Java-
	 * script variable instead of a DOM element so we can further act on that data with
	 * our JavaScript code.
	 * We can do so easily by simply assinging our method call to a JavaScript variable and
	 * accessing the .data property of the plugin as follows.
	 * The returned data may need to be parsed based on type depending on what is returned.
	 */
	var strLenA = P.strlen('some string');
	var strLenB = P.strlen('another string');
	var totalStrLen = parseInt( strLenA ) + parseInt( strLenB );
	//console.log(strLenA, strLenB, totalStrLen);
	
	
	
	/* In many situations we would like to determine the latency involved with a given code
	 * block. The 'bench' module was created to test the total time in milaseconds it takes
	 * to run your code (inclusive of response time to and from the server).
	 * To use the 'bench' method we must pass a specially structured callback function like
	 * that used below. Notice the return value is an inline annonymous function. All other
	 * code within is code you would like to test.
	 */
	var testTime = P('bench', function() {
		return (function() {
			
			var strLenA = parseInt( P.strlen('some string') );
			var strLenB = parseInt( P.strlen('another string') );
			var totalStrLen = strLenA + strLenB;
			
		});
	}, 3);
	//console.log('Test Time: ' + testTime + ' ms');
	
	// Like most other jquery.php methods we can also call 'bench' like so.
	var testTime = P(function bench() {
		return (function() {
				
			var code = "$a = 2; $b = 2; $c = $a + $b; echo $c;"
			P('exec', code, function(data, self) {
				$("#results7").html(data);
			});
			P('chain', 8, 3).pow().pi();
			
		});
	}, 3);
	//console.log('Test Time: ' + testTime + ' ms');


	// Let's switch our selector element(s) context.
	P('callback', function(data, self) {
		$(self).append("<div style='border:2px dashed purple'>"+data+"</div>");
	});
	P('select', $("#results5"));
	var result = P('chain', 8, 3).pow().pi().tan().data;
	console.log(result);
	
	/* A buffered operations mode could keep a group of related PHP requests client side and then send 
	 * them all at once to the server for execution so that they maintain the same context.
	 */
	/*
	P('block', function() {
		return (function() {
				 
	 		var someStr = "val1,val2,val3,val4,val5,val6";
			
			var explodedStr = P. explode( ",", explode );
			
			var explodedStr = P.tan( 66 );
			
			var explodedStr = P.abs ( -45 );
			
			var explodedStr = P.sin     ( 44 );
		
		});
	});
	*/
	
	// OR
	
	// !! REFACTORING REQUIRED !!
	// - The simplest option for parsing delayed block operation may be to pass a JSON block of function
	// 	 requests and variables in a JSON format.
	// - It may be less intuitive at first glance but from a programmatic stand point far easier to implement.
	// - Either way the parsing logic will be required.
	// - With that in mind it may simply be easier to expand the 'exec' mode with a backend "security filter"
	//   that is capable of combining the whitelist/blacklist to restrict illegal function calls, detecting and
	//	 preventing race conditions such as infinite loops, and other dangerous code sent from the frontend.
	/*
	P('block', 	{
		$opts : {
			http: {
				method: "GET",
				header: "Accept-language: en\r\n" +
						"Cookie: foo=bar\r\n"
			}
		},
		$context : {
			stream_context_create: [this.$opts]
		},
		$file : {
			file_get_contents: ['http://www.williamneeley.com/', false, this.$context]
		}
	});
	*/
			
});
</script>
<body>
<p><b>jQuery.php Demonstrations:</b></p>

<p>
Returned results 1 ...
<div id="results1" class="results"></div>
</p>

<p>
Returned results 2 ...
<div id="results2" class="results"></div>
</p>

<p>
Returned results 3 ...
<div id="results3" class="results"></div>
</p>

<p>
Returned results 4 ...
<div id="results4" class="results"></div>
</p>

<p>
Returned results 5 ...
<div id="results5" class="results"></div>
</p>

<p>
Returned results 6 ...
<div id="results6" class="results"></div>
</p>

<p>
Returned results 7 ...
<div id="results7" class="results"></div>
</p>

<p>
Returned results 8 ...
<div id="results8" class="results"></div>
</p>
</body>
</html>
